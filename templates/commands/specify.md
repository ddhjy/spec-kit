---
description: 从自然语言的功能描述创建或更新功能规格说明。
handoffs: 
  - label: 生成技术计划
    agent: speckit.plan
    prompt: 请根据规格说明生成实现计划。我将使用的技术栈是……
  - label: 澄清规格需求
    agent: speckit.clarify
    prompt: 请澄清规格说明中的需求
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你 **必须** 先考虑用户输入（如果不为空）。

## 大纲

触发消息中用户在 `/speckit.specify` 之后输入的文本 **就是** 功能描述。即使下面字面出现 `{ARGS}`，也假设你在本对话中始终可以拿到这段描述。除非用户的命令为空，否则不要要求用户重复。

基于该功能描述，按以下步骤执行：

1. **为分支生成一个简短名称**（2–4 个词）：
   - 分析功能描述并提取最有意义的关键词
   - 生成能概括功能本质的 2–4 词短名
   - 尽量使用“动词-名词”格式（例如 "add-user-auth"、"fix-payment-bug"）
   - 保留技术术语与缩写（OAuth2、API、JWT 等）
   - 保持简短，但要足够表达含义，让人一眼能看出是什么功能
   - 示例：
    - "我想添加用户认证" → "user-auth"
    - "为 API 实现 OAuth2 集成" → "oauth2-api-integration"
    - "为分析创建仪表盘" → "analytics-dashboard"
    - "修复支付处理超时 bug" → "fix-payment-timeout"

2. **创建新分支前先检查是否已存在分支**：

   a. 先拉取所有远端分支，确保信息是最新的：

      ```bash
      git fetch --all --prune
      ```

   b. 在所有来源中找到该 short-name 的最大 feature 编号：
      - 远端分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specs 目录：查找匹配 `specs/[0-9]+-<short-name>` 的目录

   c. 计算下一个可用编号：
      - 从三种来源中提取所有编号
      - 找到最大编号 N
      - 新分支使用 N+1

   d. 使用计算出的编号与 short-name 运行 `{SCRIPT}`：
      - 传入 `--number N+1` 与 `--short-name "your-short-name"`，并附带功能描述
      - Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 必须检查三种来源（远端分支、本地分支、specs 目录）以找到最大编号
   - 只匹配完全符合 short-name 模式的分支/目录
   - 如果找不到该 short-name 的任何分支/目录，则从编号 1 开始
   - 每个 feature 只能运行此脚本一次
   - 终端会输出 JSON——务必以 JSON 为准获取实际内容
   - JSON 输出包含 BRANCH_NAME 与 SPEC_FILE 路径
   - 参数中若包含单引号（例如 "I'm Groot"），请使用转义：例如 'I'\''m Groot'（或尽量用双引号："I'm Groot"）

3. 读取 `templates/spec-template.md`，理解必须包含的章节结构。

4. 按以下执行流程：

    1. 从用户输入解析用户描述
       - 若为空：报错 `ERROR "未提供功能描述"`
    2. 从描述中提取关键概念  
       - 识别：参与者（actors）、动作（actions）、数据（data）、约束（constraints）
    3. 对不清晰之处：  
       - 基于上下文与行业常识做“有根据的合理推断”
       - 仅在以下情况下使用 [NEEDS CLARIFICATION: 具体问题] 标注：  
         - 该选择会显著影响功能范围或用户体验
         - 存在多个合理解释且影响不同
         - 不存在合理默认值
       - **限制：最多 3 个 [NEEDS CLARIFICATION] 标记**
       - 澄清优先级：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写“用户场景与测试”章节  
       - 若无法确定清晰用户流程：报错 `ERROR "无法确定用户场景"`
    5. 生成功能性需求  
       - 每条需求必须可测试
       - 对未指定细节使用合理默认值（在 Assumptions 章节记录假设）
    6. 定义成功标准  
       - 产出可衡量、与技术无关的结果
       - 同时包含定量指标（时间、性能、规模等）与定性指标（满意度、任务完成率等）
       - 每条标准必须在不依赖实现细节的情况下可验证
    7. 识别关键实体（如果涉及数据）
    8. 返回：SUCCESS（spec 已可用于规划）

5. 按模板结构将规格说明写入 SPEC_FILE：用从功能描述（arguments）中推导出的具体细节替换占位符，并保持章节顺序与标题不变。

6. **规格质量校验**：完成初版 spec 后，按质量标准进行校验：

   a. **创建规格质量检查清单**：使用 checklist 模板结构，在 `FEATURE_DIR/checklists/requirements.md` 生成清单文件，包含以下校验项：

      ```markdown
      # 规格说明质量检查清单：[FEATURE NAME]
      
      **目的**：在进入规划前，验证规格说明的完整性与质量
      **创建时间**：[DATE]
      **Feature**：[指向 spec.md 的链接]
      
      ## 内容质量
      
      - [ ] 不包含实现细节（语言、框架、API 等）
      - [ ] 聚焦用户价值与业务需求
      - [ ] 面向非技术干系人撰写
      - [ ] 所有必填章节已完成
      
      ## 需求完整性
      
      - [ ] 不再存在 [NEEDS CLARIFICATION] 标记
      - [ ] 需求可测试且无歧义
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（不包含实现细节）
      - [ ] 已定义所有验收场景
      - [ ] 已识别边界情况
      - [ ] 范围边界清晰
      - [ ] 已识别依赖与假设
      
      ## 功能就绪度
      
      - [ ] 所有功能性需求都有清晰验收标准
      - [ ] 用户场景覆盖主流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 规格说明中没有泄露实现细节
      
      ## 备注
      
      - 被标记为未完成的条目，需要在运行 `/speckit.clarify` 或 `/speckit.plan` 之前先更新 spec
      ```

   b. **执行校验**：逐项对照清单审阅 spec：
      - 对每一项判断通过/失败
      - 记录发现的具体问题（引用相关 spec 段落）

   c. **处理校验结果**：

      - **若全部通过**：将清单标记为完成，并进入下一步

      - **若存在失败项（不含 [NEEDS CLARIFICATION]）**：
        1. 列出失败项与具体问题
        2. 更新 spec 逐一修复
        3. 重新校验直到全部通过（最多 3 轮）
        4. 若 3 轮后仍失败，在清单备注中记录剩余问题并提醒用户

      - **若仍存在 [NEEDS CLARIFICATION] 标记**：
        1. 从 spec 中提取所有 [NEEDS CLARIFICATION: ...] 标记
        2. **限制检查**：若超过 3 个，只保留最关键的 3 个（按范围/安全/UX 影响排序），其余做有根据的合理推断
        3. 对每个需要澄清的问题（最多 3 个），按如下格式给用户提供选项：

           ```markdown
           ## 问题 [N]：[Topic]
           
           **上下文**：[引用相关 spec 片段]
           
           **我们需要确认**：[来自 NEEDS CLARIFICATION 标记的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A | [建议答案 1] | [对功能的含义/影响] |
           | B | [建议答案 2] | [对功能的含义/影响] |
           | C | [建议答案 3] | [对功能的含义/影响] |
           | 自定义 | 自己提供答案 | [如何提供自定义输入] |
           
           **你的选择**：_[等待用户回复]_
           ```

        4. **关键——表格格式**：确保 Markdown 表格格式正确：
           - 使用一致的空格与对齐的管道符
           - 每个单元格内容两侧留空格：`| Content |` 而不是 `|Content|`
           - 表头分隔线至少 3 个短横线：`|--------|`
           - 在 Markdown 预览中确认表格可正常渲染
        5. 问题按顺序编号（Q1、Q2、Q3——最多 3 个）
        6. 在等待用户回复前，先一次性展示所有问题
        7. 等待用户一次性给出所有问题的选择（例如 "Q1: A, Q2: Custom - [details], Q3: B"）
        8. 用用户选择/提供的答案替换每个 [NEEDS CLARIFICATION] 标记，更新 spec
        9. 澄清完成后重新校验

   d. **更新清单**：每一轮校验后更新清单文件，记录最新通过/失败状态

7. 汇报完成情况：分支名、spec 文件路径、清单结果，以及是否已准备好进入下一阶段（`/speckit.clarify` 或 `/speckit.plan`）。

**说明：**脚本会在写入前创建并切换到新分支，并初始化 spec 文件。

## 通用指南

## 快速要点

- 聚焦用户需要什么（**WHAT**）以及为什么（**WHY**）。
- 避免讨论如何实现（HOW：不写技术栈、API、代码结构）。
- 面向业务干系人撰写，而不是面向开发者。
- 不要在 spec 内嵌任何检查清单；清单应由独立命令生成。

### Section Requirements

- **必填章节**：每个 feature 都必须完成
- **可选章节**：仅在与 feature 相关时包含
- 若某章节不适用，请直接删除（不要写成 "N/A"）

### For AI Generation

当从用户提示词生成 spec 时：

1. **做有根据的合理推断**：用上下文、行业标准与常见模式补齐缺口
2. **记录假设**：在 Assumptions 章节写明合理默认值
3. **限制澄清数量**：最多 3 个 [NEEDS CLARIFICATION] 标记——只用于会影响正确性的关键决策：
   - 会显著影响功能范围或用户体验
   - 存在多个合理解释且影响不同
   - 不存在合理默认值
4. **澄清优先级**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：任何含糊需求都应在“可测试且无歧义”这一项上失败
6. **常见需要澄清的领域**（仅当不存在合理默认值时）：
   - 功能范围与边界（明确包含/排除的用例）
   - 用户类型与权限（当存在多种冲突解释时）
   - 安全/合规需求（在法律/财务上影响显著时）

**合理默认值示例**（不要就这些提问）：

- 数据保留：该领域的行业常见实践
- 性能指标：除非明确指定，否则采用常见 Web/移动应用期望
- 错误处理：用户友好的提示与合理降级
- 认证方式：Web 应用默认基于 session 或 OAuth2
- 集成方式：除非另有说明，否则默认 RESTful API

### 成功标准指南

成功标准必须满足：

1. **可衡量**：包含明确指标（时间、百分比、数量、速率）
2. **与技术无关**：不提框架、语言、数据库或工具
3. **以用户为中心**：从用户/业务视角描述结果，而不是系统内部细节
4. **可验证**：无需知道实现细节也能测试/验证

**好的示例**：

- "用户可在 3 分钟内完成结账"
- "系统支持 10,000 并发用户"
- "95% 的搜索在 1 秒内返回结果"
- "任务完成率提升 40%"

**不好的示例**（过度偏向实现）：

- "API 响应时间低于 200ms"（过于技术化，可改为“用户几乎即时看到结果”）
- "数据库能承载 1000 TPS"（实现细节，应改为用户侧指标）
- "React 组件渲染高效"（绑定特定框架）
- "Redis 缓存命中率高于 80%"（绑定特定技术）
