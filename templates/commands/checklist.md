---
description: 基于用户需求为当前 feature 生成自定义检查清单。
scripts:
  sh: scripts/bash/check-prerequisites.sh --json
  ps: scripts/powershell/check-prerequisites.ps1 -Json
---

## 检查清单目的：“英文的单元测试”

**关键概念**：检查清单是**需求写作的单元测试**——用于验证某个领域内需求的质量、清晰度与完整性。

**不是用来做验证/测试实现**：

- ❌ 不是“验证按钮能正确点击”
- ❌ 不是“测试错误处理是否工作”
- ❌ 不是“确认 API 返回 200”
- ❌ 不是检查代码/实现是否符合规格说明

**而是用来验证需求文本质量**：

- ✅ “是否为所有卡片类型定义了视觉层级需求？”（完整性）
- ✅ “是否用具体尺寸/位置量化了‘醒目展示’？”（清晰度）
- ✅ “所有可交互元素的悬停态（hover）需求是否一致？”（一致性）
- ✅ “是否定义了键盘导航的无障碍需求？”（覆盖度）
- ✅ “当 logo 图片加载失败时，规格说明是否定义了行为？”（边界情况）

**类比**：如果把 spec 看作“用自然语言写的代码”，那么 checklist 就是它的单元测试套件。你要测试的是：需求是否写得好、是否完整、是否无歧义、是否可进入实现——而不是实现是否运行正确。

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你 **必须** 先考虑用户输入（如果不为空）。

## 执行步骤

1. **准备**：在仓库根目录运行 `{SCRIPT}`，并解析 JSON 获取 FEATURE_DIR 与 AVAILABLE_DOCS 列表。
   - 所有文件路径必须为绝对路径。
   - 参数中若包含单引号（例如 "I'm Groot"），请使用转义：例如 'I'\''m Groot'（或尽量用双引号："I'm Groot"）。

2. **澄清意图（动态生成）**：生成最多 3 个初始上下文澄清问题（不使用预置题库）。这些问题必须：
   - 基于用户措辞 + 从 spec/plan/tasks 提取的信号生成
   - 只询问那些会实质改变 checklist 内容的信息
   - 若 `$ARGUMENTS` 已经明确，则对应问题应被跳过
   - 精准优先于覆盖面

   生成算法：
   1. 提取信号：领域关键词（例如 auth、latency、UX、API）、风险指示词（"critical"、"must"、"compliance"）、干系人线索（"QA"、"review"、"security team"）、明确交付物（"a11y"、"rollback"、"contracts"）。
   2. 将信号聚类为候选关注点（最多 4 个），按相关性排序。
   3. 若未明确，推断可能的受众与使用时机（作者、评审者、QA、release）。
   4. 识别缺失维度：范围宽度、深度/严格度、风险侧重、排除边界、可衡量的验收标准。
   5. 从以下问题原型中生成问题：
      - 范围精炼（例如“是否应包含与 X/Y 的集成触点，还是仅限本地模块正确性？”）
      - 风险优先级（例如“以下哪些风险领域需要强制门禁检查？”）
      - 深度校准（例如“这是轻量的 pre-commit 清单，还是正式的 release 门禁？”）
      - 受众框定（例如“这份清单只给作者自检用，还是给 PR 评审用？”）
      - 边界排除（例如“本轮是否明确排除性能调优项？”）
      - 场景类型缺口（例如“未发现恢复流程——回滚/部分失败路径是否在范围内？”）

   问题格式规则：
   - 若提供选项，使用紧凑表格，列为：Option | Candidate | Why It Matters
   - 选项最多 A–E；若自由回答更清晰则不必用表格
   - 不要让用户重复他们已经说过的话
   - 避免臆测类别（不胡编）。不确定时，明确询问：“请确认 X 是否在范围内。”

   无法交互时的默认值：
   - 深度：Standard
   - 受众：若与代码相关则默认 Reviewer（PR），否则默认 Author
   - 关注点：相关性最高的 2 个聚类

   输出问题（标记为 Q1/Q2/Q3）。用户回答后：如果仍有 ≥2 个场景类别（Alternate / Exception / Recovery / Non-Functional）不明确，你可以再追问最多 2 个更聚焦的问题（Q4/Q5），并为每个问题给出一句理由（例如“恢复路径风险仍未解决”）。总问题数不得超过 5；若用户明确拒绝更多问题，则不要升级追问。

3. **理解用户请求**：结合 `$ARGUMENTS` 与澄清答案：
   - 推导 checklist 主题（例如 security、review、deploy、ux）
   - 汇总用户明确要求必须包含的条目
   - 将关注点选择映射到类别骨架（category scaffolding）
   - 从 spec/plan/tasks 推断缺失上下文（不得臆造）

4. **加载 feature 上下文**：从 FEATURE_DIR 读取：
   - spec.md：功能需求与范围
   - plan.md（如存在）：技术细节与依赖
   - tasks.md（如存在）：实现任务

   **上下文加载策略**：
   - 仅加载与关注点相关的必要部分（避免整文件倾倒）
   - 倾向把长段落摘要为简洁的场景/需求要点
   - 使用渐进式披露：只有发现缺口才追加读取
   - 如果源文档很大，用临时摘要条目替代粘贴原文

5. **生成 checklist** ——创建“需求的单元测试”：
   - 如不存在则创建 `FEATURE_DIR/checklists/` 目录
   - 生成唯一的清单文件名：
     - 使用基于领域的简短、可描述名称（例如 `ux.md`、`api.md`、`security.md`）
     - 格式：`[domain].md`
     - 若文件已存在，则追加到该文件
   - 条目从 CHK001 起顺序编号
   - 每次 `/speckit.checklist` 运行都会创建一个新文件（绝不覆盖既有 checklist 文件）

   **核心原则——测试需求，而不是测试实现**：
   每个 checklist 条目都必须从“需求文本本身”出发，检查：
   - **完整性**：是否包含所有必要需求？
   - **清晰度**：需求是否无歧义且具体？
   - **一致性**：需求之间是否一致且无冲突？
   - **可衡量性**：需求是否可被客观验证？
   - **覆盖度**：是否覆盖所有场景/边界情况？

   **类别结构**——按“需求质量维度”分组：
   - **需求完整性**（必要需求是否都有写？）
   - **需求清晰度**（是否具体且无歧义？）
   - **需求一致性**（是否无冲突且对齐？）
   - **验收标准质量**（成功标准是否可衡量？）
   - **场景覆盖度**（是否覆盖所有流程/情况？）
   - **边界情况覆盖度**（是否定义了边界条件？）
   - **非功能需求**（性能/安全/无障碍等是否被明确写出？）
   - **依赖与假设**（是否被记录并可验证？）
   - **歧义与冲突**（哪些地方还需要澄清？）

   **如何编写 checklist 条目（“英文的单元测试”）**：

   ❌ **错误示例**（在测试实现）：
   - “验证落地页显示 3 张节目卡片”
   - “测试桌面端 hover 状态是否工作”
   - “确认点击 logo 会回到首页”

   ✅ **正确示例**（在测试需求质量）：
   - “是否明确写出精选节目的数量与布局？”[Completeness]
   - “是否用具体尺寸/位置量化了‘醒目展示’？”[Clarity]
   - “所有可交互元素的 hover 需求是否一致？”[Consistency]
   - “是否定义了所有可交互 UI 的键盘导航需求？”[Coverage]
   - “当 logo 图片加载失败时，是否定义了降级行为？”[Edge Cases]
   - “是否定义了异步节目数据的加载状态？”[Completeness]
   - “当 UI 元素竞争注意力时，spec 是否定义了视觉层级？”[Clarity]

   **条目结构**：
   每个条目应遵循：
   - 用问题句式询问“需求质量”
   - 聚焦 spec/plan 中写了什么（或没写什么）
   - 用方括号标注质量维度 [Completeness/Clarity/Consistency/etc.]
   - 尽量引用 spec 章节：`[Spec §X.Y]`
   - 检查缺失点时使用 `[Gap]` 标记

   **按质量维度的示例**：

   完整性：
   - “是否为所有 API 失败模式定义了错误处理需求？”[Gap]
   - “是否为所有可交互元素写明无障碍需求？”[Completeness]
   - “是否定义了响应式布局的移动端断点需求？”[Gap]

   清晰度：
   - “是否为‘加载很快’量化了具体时间阈值？”[Clarity, Spec §NFR-2]
   - “是否明确写出‘相关内容’的选择标准？”[Clarity, Spec §FR-5]
   - “是否用可衡量的视觉属性定义了‘醒目’？”[Ambiguity, Spec §FR-4]

   一致性：
   - “不同页面的导航需求是否一致？”[Consistency, Spec §FR-10]
   - “落地页与详情页的卡片组件需求是否一致？”[Consistency]

   覆盖度：
   - “是否定义了零状态（无数据/无节目）的需求？”[Coverage, Edge Case]
   - “是否覆盖并发用户交互场景？”[Coverage, Gap]
   - “是否定义了部分数据加载失败时的需求？”[Coverage, Exception Flow]

   可衡量性：
   - “视觉层级需求是否可被客观验证？”[Acceptance Criteria, Spec §FR-1]
   - “‘视觉权重平衡’是否可被客观判定？”[Measurability, Spec §FR-2]

   **场景分类与覆盖**（聚焦需求质量）：
   - 检查是否包含：主流程（Primary）、替代流程（Alternate）、异常/错误（Exception/Error）、恢复（Recovery）、非功能场景（Non-Functional）
   - 对每类场景提问：“是否为 [场景类型] 给出了完整、清晰、一致的需求？”
   - 若缺失： “是否刻意排除 [场景类型]，还是遗漏？”[Gap]
   - 若存在状态变更：补充韧性/回滚项，例如“迁移失败时是否定义了回滚需求？”[Gap]

   **可追溯性要求**：
   - 最低要求：≥80% 的条目必须包含至少一个可追溯引用
   - 每条应引用 spec 章节 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`
   - 若没有 ID 体系：增加一条“是否建立了需求与验收标准的 ID 体系？”[Traceability]

   **暴露并推动解决问题**（需求质量问题）：
   询问“需求本身”：
   - 歧义：“‘fast’（快速）是否用具体指标量化？”[Ambiguity, Spec §NFR-1]
   - 冲突：“§FR-10 与 §FR-10a 的导航需求是否冲突？”[Conflict]
   - 假设：“‘播客 API 永远可用’这一假设是否被验证并写明？”[Assumption]
   - 依赖：“是否记录外部播客 API 的依赖要求？”[Dependency, Gap]
   - 缺失定义：“是否用可衡量标准定义了‘视觉层级’？”[Gap]

   **内容整合**：
   - 软上限：候选条目 > 40 时，按风险/影响排序取舍
   - 合并检查同一需求点的近似重复条目
   - 若低影响边界情况过多，用一个条目合并提问：“边界情况 X/Y/Z 是否被需求覆盖？”[Coverage]

   **🚫 绝对禁止**——这些会把它变成“实现测试”，而不是“需求测试”：
   - ❌ 任何以 “Verify（验证）/Test（测试）/Confirm（确认）/Check（检查）” 等动词开头，并直接描述实现行为的条目
   - ❌ 引用代码执行、用户点击操作、系统运行行为来“测结果”
   - ❌ “显示正确”“工作正常”“符合预期”等不可验证的描述
   - ❌ “点击/跳转/渲染/加载/执行”等实现行为用语
   - ❌ 测试用例、测试计划、QA 操作步骤
   - ❌ 实现细节（框架、API、算法）

   **✅ 必须使用的写法模式**——这些是在测试需求质量：
   - ✅ “是否为 [场景] 定义/说明/记录了 [需求类型]？”
   - ✅ “是否用具体标准量化/澄清了 [模糊术语]？”
   - ✅ “章节 A 与章节 B 的需求是否一致？”
   - ✅ “[需求] 是否可被客观衡量/验证？”
   - ✅ “是否覆盖了 [边界情况/场景] 的需求？”
   - ✅ “spec 是否定义了 [缺失的方面]？”

6. **结构参考**：按 `templates/checklist-template.md` 的规范模板生成 checklist（标题、元信息、分类标题、ID 格式）。若模板不可用，则使用：H1 标题 + purpose/created 元信息 + `##` 分类章节；每条为 `- [ ] CHK### <条目>`，并从 CHK001 全局递增。

7. **汇报**：输出创建的 checklist 的绝对路径、条目数，并提醒：每次运行都会创建新文件。摘要包括：
   - 选择的关注点
   - 深度等级
   - 受众/时机
   - 融合进来的用户“必须包含”项

**重要**：每次 `/speckit.checklist` 调用都会创建一个使用简短、可描述名称的 checklist 文件（除非同名文件已存在）。这带来：

- 多种类型的 checklist 并存（例如 `ux.md`、`test.md`、`security.md`）
- 文件名简短、好记，能体现用途
- 在 `checklists/` 目录中易于识别与导航

为避免杂乱，请使用描述性类型命名，并在不需要时清理过时的 checklist。

## 示例：Checklist 类型与示例条目

**UX 需求质量：**`ux.md`

示例条目（测试需求，而不是测试实现）：

- “是否用可衡量标准定义了视觉层级需求？”[Clarity, Spec §FR-1]
- “是否明确写出 UI 元素的数量与位置？”[Completeness, Spec §FR-1]
- “交互状态（hover/focus/active）需求是否一致？”[Consistency]
- “是否为所有可交互元素定义无障碍需求？”[Coverage, Gap]
- “图片加载失败时是否定义降级行为？”[Edge Case, Gap]
- “‘醒目展示’是否可被客观测量？”[Measurability, Spec §FR-4]

**API 需求质量：**`api.md`

示例条目：

- “是否为所有失败场景指定错误响应格式？”[Completeness]
- “是否用具体阈值量化限流需求？”[Clarity]
- “各端点的认证需求是否一致？”[Consistency]
- “外部依赖的重试/超时需求是否被定义？”[Coverage, Gap]
- “需求中是否写明版本策略？”[Gap]

**性能需求质量：**`performance.md`

示例条目：

- “性能需求是否用具体指标量化？”[Clarity]
- “是否为所有关键用户旅程定义性能目标？”[Coverage]
- “是否说明不同负载条件下的性能需求？”[Completeness]
- “性能需求是否可被客观衡量？”[Measurability]
- “高负载下的降级需求是否定义？”[Edge Case, Gap]

**安全需求质量：**`security.md`

示例条目：

- “是否为所有受保护资源定义认证需求？”[Coverage]
- “是否为敏感信息定义数据保护需求？”[Completeness]
- “是否记录威胁模型，并确保需求与其对齐？”[Traceability]
- “安全需求是否与合规义务一致？”[Consistency]
- “安全失败/泄露后的响应需求是否定义？”[Gap, Exception Flow]

## 反例：不要这样做

**❌ 错误——这些是在测试实现，而不是测试需求：**

```markdown
- [ ] CHK001 - 验证落地页显示 3 张节目卡片 [Spec §FR-001]
- [ ] CHK002 - 测试桌面端 hover 状态是否正常 [Spec §FR-003]
- [ ] CHK003 - 确认点击 logo 会跳转到首页 [Spec §FR-010]
- [ ] CHK004 - 检查相关内容区域是否显示 3–5 项 [Spec §FR-005]
```

**✅ 正确——这些是在测试需求质量：**

```markdown
- [ ] CHK001 - 是否明确写出精选节目的数量与布局？ [Completeness, Spec §FR-001]
- [ ] CHK002 - hover 状态需求是否对所有可交互元素一致？ [Consistency, Spec §FR-003]
- [ ] CHK003 - 对所有可点击品牌元素的导航需求是否清晰？ [Clarity, Spec §FR-010]
- [ ] CHK004 - 是否记录相关内容的选择标准？ [Gap, Spec §FR-005]
- [ ] CHK005 - 是否定义异步数据的加载状态需求？ [Gap]
- [ ] CHK006 - “视觉层级”需求是否可被客观测量？ [Measurability, Spec §FR-001]
```

**关键差异：**

- 错误：在测试系统是否“做对了”
- 正确：在测试需求是否“写对了”
- 错误：验证行为
- 正确：验证需求质量
- 错误：“它是否做了 X？”
- 正确：“X 是否被清晰地写明？”
