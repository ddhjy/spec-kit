# 规格驱动开发（Specification-Driven Development，SDD）

## 权力反转

几十年来，代码一直是“王”。规格说明服务于代码——它们像我们搭建的脚手架：一旦真正的编码工作开始，就被丢到一边。我们会写 PRD 来指导开发，写设计文档来辅助实现，画图来表达架构。但这些产物始终从属于代码本身。代码才是真相；其他一切，最多只是“良好意图”。代码成为事实来源，而代码一旦向前推进，规格说明往往跟不上。由于资产（代码）与实现几乎等同，没有直接从代码构建的情况下，要做并行实现并不容易。

规格驱动开发（SDD）把这种权力结构倒过来：规格说明不再服务于代码——**代码服务于规格说明**。产品需求文档（PRD）不再只是实现的指导，而是**生成实现的源头**。技术计划不再是“写给人看的说明文档”，而是**能产出代码的精确定义**。这不是对软件构建方式的小修小补，而是对“开发由什么驱动”的一次根本性重思。

规格与实现之间的鸿沟，自软件开发诞生起就一直存在。我们尝试用更好的文档、更详细的需求、更严格的流程来弥合它。但这些方法之所以失败，是因为它们默认“鸿沟不可避免”：只能缩小，无法消除。SDD 通过让“规格说明”及其从规格说明中诞生的“具体实现计划”变得可执行，从而消除鸿沟。当规格说明与实现计划可以生成代码时，就不再有鸿沟——只有“变换”（transformation）。

这种变换之所以在今天成为可能，是因为 AI 可以理解并实现复杂规格，并生成细致的实现计划。但缺少结构的原始 AI 生成会带来混乱。SDD 通过足够精确、完整、无歧义的规格说明与后续实现计划提供结构，从而生成可工作的系统。规格说明成为第一等公民的产物；代码则成为其在某种语言与框架中的表达（由实现计划推导出的实现）。

在这个新世界里，维护软件意味着演进规格说明。开发团队的意图通过自然语言（“**意图驱动开发**”）、设计资产、核心原则与其他指南表达。开发的通用语（lingua franca）上移到更高层级，代码变成“最后一公里”。

调试意味着修正那些生成了错误代码的规格说明与实现计划；重构意味着为了清晰性而重组结构。整个开发工作流围绕规格说明重新组织：规格说明是中心事实来源，实现计划与代码是持续再生成的输出。为应用增加新功能，或因为创意而做一份并行实现，都意味着回到规格说明并创建新的实现计划。因此这个过程更像：0 → 1 →（1′、…）→ 2 → 3 → N。

开发团队由此可以把更多精力聚焦到创造力、实验与批判性思考上。

## SDD 工作流在实践中的样子

工作流往往从一个想法开始——通常模糊且不完整。通过与 AI 的迭代对话，这个想法逐步变成一份完整的 PRD。AI 会提出澄清问题、识别边界情况，并帮助定义精确的验收标准。传统开发中可能需要数天会议与文档撰写的事情，在这里可以在数小时的高强度规格工作中完成。这也改变了传统 SDLC：需求与设计不再是离散阶段，而成为持续活动。这同样支持**团队流程**：团队评审的规格说明会被表达与版本化，创建在分支里并最终合并。

当产品经理更新验收标准时，实现计划会自动标记受影响的技术决策；当架构师发现更优模式时，PRD 也会更新以反映新的可能性。

在规格工作的全过程中，研究型 agent 会收集关键上下文：例如库的兼容性、性能基准、安全影响等。组织约束也会被发现并自动应用——公司的数据库标准、认证要求、部署策略会无缝融入每一份规格说明。

基于 PRD，AI 会生成把需求映射到技术决策的实现计划：每个技术选择都有记录在案的理由；每个架构决策都能追溯到具体需求。在这个过程中，一致性校验会持续提升质量：AI 会分析规格说明中的歧义、矛盾与缺口——不是一次性的门禁，而是持续精炼。

一旦规格说明与实现计划稳定到足以生成代码，代码生成就可以开始——它们不必先“完美完整”。早期的生成可以是探索性的：用来验证规格在实践中是否合理。领域概念变成数据模型；用户故事变成 API 端点；验收场景变成测试。这把开发与测试通过规格说明融合在一起——测试场景不是在代码之后补写，而是规格的一部分，用来同时生成实现与测试。

反馈循环也会超越初始开发：生产指标与事故不只是触发热修复（hotfix），它们会更新规格说明，服务于下一次再生成。性能瓶颈会成为新的非功能需求；安全漏洞会成为影响后续所有生成的约束。规格、实现与运行现实之间的这种迭代舞步，是真正理解产生的地方，也是传统 SDLC 演化为持续演进的地方。

## 为什么 SDD 在当下重要

三大趋势让 SDD 不仅“可行”，而且“必要”：

第一，AI 能力已达到一个阈值：自然语言规格说明可以相对可靠地生成可工作的代码。这不是要取代开发者，而是通过自动化“从规格到实现”的机械翻译来放大开发者效能——它能增强探索与创造力，支持轻松“推倒重来”，并支持增删与批判性思考。

第二，软件复杂度仍在指数级增长。现代系统集成了数十种服务、框架与依赖。用手工流程让这些部分与最初意图保持一致变得越来越困难。SDD 通过规格驱动生成提供系统化对齐。框架也可能演进为更偏 AI-first（而非 human-first），或围绕可复用组件组织。

第三，变化速度持续加快。需求的变化频率比以往任何时候都高；转向（pivot）不再是例外，而成为常态。现代产品开发要求基于用户反馈、市场条件与竞争压力快速迭代。传统开发把这些变化当作“打断”。每次转向都需要手工把变更传播到文档、设计与代码中，结果要么更新缓慢谨慎导致速度受限，要么更新迅猛草率积累技术债。

SDD 也能支持“what-if/仿真”实验：例如“如果我们为了卖更多 T 恤而需要重做或改造应用，我们该如何实现并验证这些实验？”

SDD 把需求变化从障碍变成常规工作流：当规格驱动实现时，转向变成系统化再生成，而不是手工重写。只要修改 PRD 中的核心需求，受影响的实现计划会自动更新；修改一个用户故事，对应的 API 端点会再生成。这不仅关乎初始开发，更关乎在不可避免的变化中保持工程速度。

## 核心原则

**规格说明作为通用语**：规格说明成为主要产物；代码成为其在某种语言与框架中的表达。维护软件意味着演进规格说明。

**可执行的规格说明**：规格说明必须足够精确、完整且无歧义，才能生成可工作的系统，从而消除意图与实现之间的鸿沟。

**持续精炼**：一致性校验持续进行，而不是一次性的门禁。AI 会持续分析规格说明中的歧义、矛盾与缺口。

**研究驱动的上下文**：研究型 agent 在规格过程中收集关键上下文，调研技术选项、性能影响与组织约束。

**双向反馈**：生产现实反过来驱动规格演进。指标、事故与运维经验成为规格精炼的输入。

**为探索而分支**：从同一份规格说明生成多种实现方式，探索不同优化目标——性能、可维护性、用户体验、成本。

## 实践方式

在今天，要实践 SDD 需要把现有工具组合起来，并在流程中保持纪律性。可以借助：

- 用于迭代式规格开发的 AI 助手
- 用于收集技术上下文的研究型 agent
- 用于将规格翻译为实现的代码生成工具
- 适配“规格优先”工作流的版本控制系统
- 通过 AI 分析规格文档进行一致性检查

关键在于把规格说明当作事实来源，而代码是服务于规格说明的生成输出（而不是反过来）。

## 用命令简化 SDD

SDD 方法论可以通过三条强力命令得到显著增强：它们把“规格说明 → 计划 → 任务拆分”的工作流自动化。

### `/speckit.specify` 命令

该命令可以把一段简单的功能描述（用户提示词）转换成一份完整、结构化的规格说明，并自动管理仓库：

1. **自动编号**：扫描现有 specs，确定下一个功能编号（例如 001、002、003）
2. **创建分支**：根据你的描述生成语义化分支名，并自动创建
3. **基于模板生成**：复制并按你的需求定制功能规格模板
4. **目录结构**：为相关文档创建正确的 `specs/[branch-name]/` 结构

### `/speckit.plan` 命令

当功能规格说明已经存在后，该命令会生成一份全面的实现计划：

1. **规格分析**：阅读并理解功能需求、用户故事与验收标准
2. **遵循 Constitution**：确保与项目宪章（constitution）与架构原则一致
3. **技术翻译**：把业务需求转换为技术架构与实现细节
4. **配套文档**：生成数据模型、API 合同、测试场景等支撑文档
5. **快速验证**：产出 quickstart 指南，覆盖关键验证场景

### `/speckit.tasks` 命令

在计划生成后，该命令会分析计划与相关设计文档，生成可执行的任务清单：

1. **输入**：读取 `plan.md`（必需）；若存在也会读取 `data-model.md`、`contracts/`、`research.md`
2. **任务推导**：将合同、实体与场景转换为具体任务
3. **并行化**：为可独立执行的任务标注 `[P]`，并给出安全的并行分组
4. **输出**：在 feature 目录写入 `tasks.md`，可直接交给任务执行型 agent

### 示例：构建聊天功能

下面展示这三条命令如何改造传统开发流程：

**传统方式：**

```text
1. 在文档中编写 PRD（2–3 小时）
2. 编写设计文档（2–3 小时）
3. 手动搭建项目结构（30 分钟）
4. 编写技术规格（3–4 小时）
5. 制作测试计划（2 小时）
合计：约 12 小时的文档工作
```

**使用命令的 SDD 方式：**

```bash
# 步骤 1：创建功能规格（5 分钟）
/speckit.specify Real-time chat system with message history and user presence

# 将自动：
# - 创建分支 "003-chat-system"
# - 生成 specs/003-chat-system/spec.md
# - 填充结构化需求

# 步骤 2：生成实现计划（5 分钟）
/speckit.plan WebSocket for real-time messaging, PostgreSQL for history, Redis for presence

# 步骤 3：生成可执行任务（5 分钟）
/speckit.tasks

# 将自动创建：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md（WebSocket 库对比）
# - specs/003-chat-system/data-model.md（Message 与 User 的 schema）
# - specs/003-chat-system/contracts/（WebSocket 事件、REST 端点）
# - specs/003-chat-system/quickstart.md（关键验证场景）
# - specs/003-chat-system/tasks.md（由计划推导出的任务清单）
```

15 分钟内你就能得到：

- 一份包含用户故事与验收标准的完整功能规格说明
- 一份带技术选型与理由的详细实现计划
- 可直接用于代码生成的 API 合同与数据模型
- 覆盖自动化与手工测试的完整测试场景
- 以上文档均在 feature 分支中完成版本化管理

### 结构化自动化的力量

这些命令不只是省时间——它们还强制“一致性”与“完整性”：

1. **不遗漏细节**：模板确保从非功能需求到错误处理都被覆盖
2. **决策可追溯**：每个技术选择都能回溯到具体需求
3. **活文档**：规格说明与代码保持同步，因为代码由规格生成
4. **快速迭代**：改需求后几分钟即可再生成计划，而不是耗费数天

这些命令把规格说明当作“可执行产物”而非静态文档，从而体现 SDD 原则：它把“不得不写的文档工作”转变为真正驱动开发的力量。

### 模板驱动质量：结构如何约束 LLM 产出更好的结果

这些命令真正的力量不只在自动化，更在于模板如何引导 LLM 行为，产出更高质量的规格说明。模板像一组精心设计的提示词，以建设性的方式约束 LLM 输出：

#### 1. **防止过早引入实现细节**

功能规格模板会明确要求：

```text
- ✅ 聚焦用户需要什么（WHAT）以及为什么（WHY）
- ❌ 避免讨论如何实现（HOW：不写技术栈、API、代码结构）
```

这种约束迫使 LLM 保持合适的抽象层级。当 LLM 可能会自然地跳到“用 React + Redux 实现”时，模板会把它拉回到“用户需要数据的实时更新”。这种分离能确保即便实现技术变化，规格说明也依旧稳定。

#### 2. **强制显式标注不确定性**

两个模板都会强制使用 `[NEEDS CLARIFICATION]` 标记：

```text
当从用户提示词生成 spec 时：
1. **标注所有歧义**：使用 [NEEDS CLARIFICATION: 具体问题]
2. **不要猜**：提示词没说清楚的地方就标注出来
```

这能避免 LLM 常见的行为：做出看似合理但可能错误的假设。比如面对“登录系统”，LLM 不能直接猜测是邮箱/密码，而必须标注为：`[NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]`。

#### 3. **用清单强制结构化思考**

模板包含一套全面清单，像是规格说明的“单元测试”：

```markdown
### 需求完整性

- [ ] 不再存在 [NEEDS CLARIFICATION] 标记
- [ ] 需求可测试且无歧义
- [ ] 成功标准可量化
```

这些清单会迫使 LLM 系统化地自检输出，捕捉那些本来可能漏掉的缺口，就像给 LLM 配了一套质量保障框架。

#### 4. **用“门禁”确保遵循 Constitution**

实现计划模板通过阶段门禁来强制执行架构原则：

```markdown
### 阶段 -1：实现前门禁

#### 简洁性门禁（第 VII 条）

- [ ] 项目数 ≤ 3？
- [ ] 没有“为未来预留/过度前瞻”的设计？

#### 反抽象门禁（第 VIII 条）

- [ ] 直接使用框架能力？
- [ ] 单一模型表达（不做多套重复模型）？
```

这些门禁通过要求 LLM 明确解释任何复杂性来防止过度工程化。如果门禁未通过，LLM 必须在“复杂度追踪（Complexity Tracking）”章节记录原因，为架构决策建立可追责性。

#### 5. **分层管理细节**

模板会强制合理的信息架构：

```text
**重要**：这份实现计划应保持高层次且可读。
任何代码示例、详细算法或大段技术规格
必须放入对应的 `implementation-details/` 文件中
```

这能避免规格说明沦为“不可读的代码倾倒区”。LLM 会学会保持合适的细节层级：把复杂内容拆到独立文件，同时保持主文档可导航。

#### 6. **测试优先思维**

实现模板会强制“测试先行”：

```text
### 文件创建顺序
1. 先创建 `contracts/`（API 规格）
2. 按顺序创建测试文件：contract → integration → e2e → unit
3. 再创建源码文件以让测试通过
```

这种顺序约束确保 LLM 在实现之前先考虑可测试性与合同（contract），从而产出更健壮、可验证的规格说明。

#### 7. **防止“臆想功能”**

模板会明确禁止臆测：

```text
- [ ] 不引入“可能需要”的臆想功能
- [ ] 每个阶段都有清晰的前置条件与交付物
```

这能阻止 LLM 添加会增加实现复杂度的“可有可无”功能。每个功能都必须能追溯到具体用户故事，并且有明确验收标准。

### 复合效应

这些约束协同作用，会让规格说明具备：

- **完整**：清单确保不遗漏
- **无歧义**：强制澄清标记凸显不确定性
- **可测试**：流程内建测试优先思维
- **可维护**：合适的抽象层级与信息层次结构
- **可实现**：阶段清晰且交付物明确

模板把 LLM 从“创意写作者”转变为“有纪律的规格工程师”，把能力导向稳定地产出高质量、可执行、真正驱动开发的规格说明。

## 宪章基础：强制架构纪律

SDD 的核心是 constitution（宪章）：一组不可动摇的原则，用于规范“规格如何变成代码”。宪章（`memory/constitution.md`）像系统的架构 DNA，确保每一次生成的实现都保持一致、简洁与高质量。

### 开发九条（Nine Articles）

宪章定义了九条原则，塑造开发流程的方方面面：

#### 第 I 条：库优先原则（Library-First）

每个功能都必须以独立库开始——没有例外。这从一开始就强制模块化设计：

```text
Specify 中的每个功能都必须以独立库的形式开始存在。
任何功能都不得直接在应用代码中实现，
必须先抽象为可复用的库组件。
```

该原则确保规格说明生成的是模块化、可复用的代码，而不是单体式应用。当 LLM 生成实现计划时，必须把功能组织为边界清晰、依赖最小的库。

#### 第 II 条：CLI 接口强制（CLI Interface）

每个库都必须通过命令行接口暴露其功能：

```text
所有 CLI 接口都必须：
- 接受文本作为输入（stdin、参数或文件）
- 输出文本（stdout）
- 支持 JSON 格式用于结构化数据交换
```

这强制保证可观测性与可测试性。LLM 不能把功能藏在“黑盒类”里——一切都必须能通过文本接口被访问与验证。

#### 第 III 条：测试优先（Test-First，强制）

最具变革性的条款：**没有测试就不写代码**。

```text
这是不可协商的：所有实现都必须严格遵循测试驱动开发（TDD）。
在以下事项完成之前，不得编写任何实现代码：
1. 已编写单元测试
2. 测试已被用户验证并批准
3. 已确认测试失败（红灯阶段）
```

这彻底颠覆了传统的 AI 代码生成方式：不是先生成代码然后祈祷它能跑，而是必须先生成定义行为的全面测试、得到批准，再生成实现。

#### 第 VII 与第 VIII 条：简洁与反抽象

这对条款用来对抗过度工程化：

```text
第 7.3 节：最小化项目结构
- 初始实现最多 3 个项目
- 增加项目必须有书面理由说明

第 8.1 节：信任框架
- 直接使用框架能力，而不是再包一层
```

当 LLM 倾向于自然地产生复杂抽象时，这些条款会迫使它为每一层复杂性给出理由。实现计划模板中的“阶段 -1 门禁”会直接执行这些原则。

#### 第 IX 条：集成优先测试（Integration-First）

优先在真实环境中测试，而不是只做隔离的单元测试：

```text
测试必须使用真实环境：
- 优先使用真实数据库而非 mock
- 优先使用真实服务实例而非 stub
- 在实现之前必须先写 contract 测试
```

这确保生成的代码在实践中可用，而不只是理论上成立。

### 通过模板执行宪章原则

实现计划模板通过具体检查点把这些条款“落地可执行”：

```markdown
### 阶段 -1：实现前门禁

#### 简洁性门禁（第 VII 条）

- [ ] 项目数 ≤ 3？
- [ ] 没有“为未来预留/过度前瞻”的设计？

#### 反抽象门禁（第 VIII 条）

- [ ] 直接使用框架能力？
- [ ] 单一模型表达（不做多套重复模型）？

#### 集成优先门禁（第 IX 条）

- [ ] 已定义 contracts？
- [ ] 已编写 contract 测试？
```

这些门禁就像架构原则的“编译期检查”。LLM 不能在未通过门禁的情况下继续推进，除非在“复杂度追踪（Complexity Tracking）”章节中记录并论证合理的例外情况。

### 不可变原则的力量

宪章的力量在于其不可变性：实现细节可以演化，但核心原则保持不变。这带来：

1. **跨时间一致性**：今天生成的代码与明年生成的代码遵循同一套原则
2. **跨模型一致性**：不同 AI 模型也能产出架构上兼容的代码
3. **架构完整性**：每个功能都强化（而不是削弱）系统设计
4. **质量保证**：测试优先、库优先与简洁原则确保代码可维护

### 宪章的演进

原则不可变，但其应用方式可以演进：

```text
第 4.2 节：修订流程
对宪章的修改需要：
- 明确记录修改原因
- 项目维护者评审并批准
- 评估向后兼容性
```

这让方法论能够在保持稳定性的同时学习与改进。宪章也会通过带日期的修订记录展示其自我演进，说明原则如何基于真实经验被精炼。

### 不止规则：一种开发哲学

宪章不只是规则手册——它是一种哲学，塑造 LLM 如何思考代码生成：

- **可观测优先于黑盒**：一切必须能通过 CLI 接口被检查
- **简洁优先于聪明**：先从简单开始，只有在证明必要时才增加复杂度
- **集成优先于隔离**：在真实环境测试，而不是在人工构造环境里自嗨
- **模块化优先于单体**：每个功能都是边界清晰的库

通过把这些原则嵌入规格与计划流程，SDD 确保生成的代码不止“能用”，而是可维护、可测试、架构健全。宪章把 AI 从“代码生成器”转变为尊重并强化系统设计原则的“架构伙伴”。

## 这场变换

这不是要取代开发者，也不是要自动化创造力，而是通过自动化机械翻译来放大人的能力。它要建立一个紧密的反馈环：规格说明、研究与代码共同演进；每一次迭代都带来更深的理解，以及意图与实现之间更好的对齐。

软件开发需要更好的工具来维持“意图”与“实现”的对齐。SDD 提供了一种方法论：通过能生成代码的可执行规格说明来实现这种对齐，而不仅仅是用规格说明去“指导”实现。
